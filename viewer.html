<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador 3D - Gus</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #controls h2 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #ffffff;
        }

        .camera-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            background: #333333;
            color: #ffffff;
            border: 2px solid #555555;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .camera-btn:hover {
            background: #444444;
            border-color: #777777;
            transform: translateX(5px);
        }

        .camera-btn.active {
            background: #0066cc;
            border-color: #0088ff;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }

        #loading-bar {
            width: 300px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 20px;
        }

        #loading-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0066cc, #0088ff);
            transition: width 0.3s ease;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            color: #aaaaaa;
        }

        @media (max-width: 768px) {
            #controls {
                width: calc(100% - 40px);
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="loading">
        <h1>Carregando modelo 3D...</h1>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
        <p id="loading-percent">0%</p>
    </div>

    <div id="controls" style="display: none;">
        <h2>üì∑ C√¢meras</h2>
        <div id="camera-buttons"></div>
    </div>

    <div id="info">
        <strong>Visualizador 3D</strong><br>
        Modelo: Gus<br>
        Anima√ß√µes: Bra√ßo + Boca (Loop)
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/ShaderPass.js"></script>

    <script>
        // ===== CONFIGURA√á√ÉO =====
        const CONFIG = {
            modelPath: 'mr_penguin.glb'
        };

        // ===== VARI√ÅVEIS GLOBAIS =====
        let scene, renderer, currentCamera;
        let model, mixer, clock;
        let cameras = [];
        let animations = [];
        let composer; // EffectComposer para p√≥s-processamento

        // ===== SHADER DE SATURA√á√ÉO =====
        const SaturationShader = {
            uniforms: {
                tDiffuse: { value: null },
                saturation: { value: 0.7 } // 0.7 = 70% satura√ß√£o (reduz 30%)
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float saturation;
                varying vec2 vUv;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    vec3 grayVec = vec3(gray);
                    gl_FragColor = vec4(mix(grayVec, color.rgb, saturation), color.a);
                }
            `
        };

        // ===== ELEMENTOS DOM =====
        const loadingDiv = document.getElementById('loading');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingPercent = document.getElementById('loading-percent');
        const controlsDiv = document.getElementById('controls');
        const cameraButtonsDiv = document.getElementById('camera-buttons');

        // ===== INICIALIZA√á√ÉO =====
        function init() {
            console.log('üöÄ Inicializando visualizador 3D...');

            // Criar cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Configurar renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // TESTE: Desabilitar sombras para ver se remove linhas nas cortinas
            renderer.shadowMap.enabled = false;
            // renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Color space e tone mapping corretos
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.NoToneMapping;
            console.log('üé® Color space: sRGB, Tone mapping: None');

            // ===== DEBUG COMPLETO DO RENDERER =====
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('=== RENDERER CONFIG ===');
            console.log('pixelRatio:', renderer.getPixelRatio());
            console.log('outputColorSpace:', renderer.outputColorSpace);
            console.log('toneMapping:', renderer.toneMapping);
            console.log('toneMappingExposure:', renderer.toneMappingExposure);
            console.log('shadowMap.enabled:', renderer.shadowMap.enabled);
            console.log('shadowMap.type:', renderer.shadowMap.type);
            console.log('antialias:', renderer.capabilities.isWebGL2);
            console.log('maxAnisotropy:', renderer.capabilities.getMaxAnisotropy());
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ===== CONFIGURAR P√ìS-PROCESSAMENTO =====
            // NOTA: O composer ser√° configurado ap√≥s carregar o modelo (precisa da c√¢mera)
            console.log('üé¨ P√≥s-processamento ser√° configurado ap√≥s carregar o modelo');

            // Clock para anima√ß√µes
            clock = new THREE.Clock();

            // Carregar modelo
            loadModel();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
        }

        // ===== CARREGAMENTO DO MODELO =====
        function loadModel() {
            const loader = new THREE.GLTFLoader();

            loader.load(
                CONFIG.modelPath,
                (gltf) => {
                    console.log('‚úÖ GLB carregado com sucesso!');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    model = gltf.scene;
                    scene.add(model);

                    // ===== DEBUG: LISTAR TODOS OS OBJETOS =====
                    console.log('üîç DEBUG - LISTANDO TODOS OS OBJETOS NO GLB:');
                    let meshCount = 0;
                    let morphTargetCount = 0;

                    gltf.scene.traverse((child) => {
                        console.log('  -', child.type, ':', child.name);

                        // Contar meshes e morphTargets
                        if (child.isMesh) {
                            meshCount++;
                            if (child.morphTargetInfluences && child.morphTargetInfluences.length > 0) {
                                morphTargetCount++;
                                console.log('    ‚Üí Mesh com', child.morphTargetInfluences.length, 'morphTargets (Shape Keys)');
                            }
                        }
                    });

                    console.log('üìä Total de meshes:', meshCount);
                    console.log('üìä Meshes com morphTargets:', morphTargetCount);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== EXTRAIR C√ÇMERAS DO GLB =====
                    console.log('üì∑ Procurando c√¢meras no GLB...');
                    gltf.scene.traverse((child) => {
                        if (child.type === 'PerspectiveCamera' || child.type === 'OrthographicCamera' || child.isCamera) {
                            cameras.push(child);
                            console.log('  ‚úì C√¢mera encontrada:', child.name, '- Tipo:', child.type);
                            console.log('    Posi√ß√£o:', child.position.x.toFixed(2), child.position.y.toFixed(2), child.position.z.toFixed(2));

                            // Atualizar aspect ratio se for PerspectiveCamera
                            if (child.isPerspectiveCamera) {
                                child.aspect = window.innerWidth / window.innerHeight;
                                child.updateProjectionMatrix();
                            }
                        }
                    });

                    console.log('üì∑ Total de c√¢meras encontradas:', cameras.length);

                    // Se n√£o encontrar c√¢meras, criar uma padr√£o BEM POSICIONADA
                    if (cameras.length === 0) {
                        console.warn('‚ö†Ô∏è Nenhuma c√¢mera encontrada no GLB. Criando c√¢mera padr√£o...');

                        // Calcular bounding box do modelo para posicionar c√¢mera
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());

                        const maxDim = Math.max(size.x, size.y, size.z);
                        const fov = 50;
                        const cameraDistance = maxDim / (2 * Math.tan((fov * Math.PI) / 360));

                        const defaultCamera = new THREE.PerspectiveCamera(
                            fov,
                            window.innerWidth / window.innerHeight,
                            0.1,
                            cameraDistance * 10
                        );
                        defaultCamera.position.set(
                            center.x + cameraDistance,
                            center.y + cameraDistance * 0.5,
                            center.z + cameraDistance
                        );
                        defaultCamera.lookAt(center);
                        defaultCamera.name = 'Camera_Padr√£o';
                        cameras.push(defaultCamera);
                        scene.add(defaultCamera);

                        console.log('üì∑ C√¢mera padr√£o criada na posi√ß√£o:', defaultCamera.position);
                        console.log('üì∑ Olhando para:', center);
                    }

                    // Definir c√¢mera inicial
                    currentCamera = cameras[0];
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('üì∑ C√ÇMERA ATIVA:', currentCamera.name);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== CONFIGURAR P√ìS-PROCESSAMENTO COM SATURA√á√ÉO =====
                    console.log('üé¨ Configurando p√≥s-processamento...');
                    composer = new THREE.EffectComposer(renderer);

                    // RenderPass - renderiza a cena normal
                    const renderPass = new THREE.RenderPass(scene, currentCamera);
                    composer.addPass(renderPass);

                    // ShaderPass com satura√ß√£o reduzida
                    const saturationPass = new THREE.ShaderPass(SaturationShader);
                    saturationPass.renderToScreen = true;
                    composer.addPass(saturationPass);

                    console.log('‚úÖ P√≥s-processamento configurado');
                    console.log('   - Satura√ß√£o:', SaturationShader.uniforms.saturation.value * 100 + '%');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== CONFIGURAR COLOR SPACE DAS TEXTURAS =====
                    console.log('üé® Configurando color space das texturas...');
                    let texturesProcessed = 0;

                    gltf.scene.traverse((child) => {
                        if (child.isMesh && child.material) {
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach(mat => {
                                // Configurar color space para TODAS as texturas
                                if (mat.map) {
                                    mat.map.colorSpace = THREE.SRGBColorSpace;
                                    texturesProcessed++;
                                }
                                if (mat.emissiveMap) {
                                    mat.emissiveMap.colorSpace = THREE.SRGBColorSpace;
                                    texturesProcessed++;
                                }
                                if (mat.normalMap) {
                                    mat.normalMap.colorSpace = THREE.LinearSRGBColorSpace;
                                    texturesProcessed++;
                                }
                                if (mat.roughnessMap) {
                                    mat.roughnessMap.colorSpace = THREE.LinearSRGBColorSpace;
                                    texturesProcessed++;
                                }
                                if (mat.metalnessMap) {
                                    mat.metalnessMap.colorSpace = THREE.LinearSRGBColorSpace;
                                    texturesProcessed++;
                                }

                                mat.needsUpdate = true;
                            });
                        }
                    });

                    console.log('‚úÖ Color space configurado');
                    console.log('üé® Texturas processadas:', texturesProcessed);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== RECALCULAR NORMAIS DAS CORTINAS =====
                    console.log('üîß Recalculando normais das cortinas...');
                    let cortinasProcessadas = 0;

                    model.traverse((child) => {
                        if (child.isMesh) {
                            // Se for cortina, recalcula normais
                            if (child.name.toLowerCase().includes('cortina')) {
                                child.geometry.computeVertexNormals();

                                // For√ßa smooth shading
                                if (child.material) {
                                    child.material.flatShading = false;
                                    child.material.needsUpdate = true;
                                }

                                console.log('  ‚úì Cortina processada:', child.name);
                                cortinasProcessadas++;
                            }
                        }
                    });

                    console.log('‚úÖ Normais recalculadas');
                    console.log('üîß Cortinas processadas:', cortinasProcessadas);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== DEBUG DETALHADO DAS CORTINAS =====
                    console.log('üîç DEBUG DETALHADO - MATERIAIS DAS CORTINAS:');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    model.traverse((child) => {
                        if (child.isMesh && child.name.toLowerCase().includes('cortina')) {
                            console.log('=== CORTINA:', child.name, '===');
                            console.log('  geometry vertices:', child.geometry.attributes.position.count);
                            console.log('  geometry hasNormals:', !!child.geometry.attributes.normal);
                            console.log('  geometry hasUVs:', !!child.geometry.attributes.uv);

                            if (child.material) {
                                const mat = Array.isArray(child.material) ? child.material[0] : child.material;
                                console.log('  material type:', mat.type);
                                console.log('  flatShading:', mat.flatShading);
                                console.log('  wireframe:', mat.wireframe);
                                console.log('  side:', mat.side === THREE.FrontSide ? 'FrontSide' :
                                                       mat.side === THREE.BackSide ? 'BackSide' :
                                                       mat.side === THREE.DoubleSide ? 'DoubleSide' : mat.side);
                                console.log('  transparent:', mat.transparent);
                                console.log('  opacity:', mat.opacity);

                                if (mat.map) {
                                    console.log('  texture:', {
                                        width: mat.map.image?.width,
                                        height: mat.map.image?.height,
                                        colorSpace: mat.map.colorSpace,
                                        minFilter: mat.map.minFilter,
                                        magFilter: mat.map.magFilter
                                    });
                                }

                                if (mat.color) {
                                    console.log('  color RGB:', mat.color.r.toFixed(3), mat.color.g.toFixed(3), mat.color.b.toFixed(3));
                                }
                            }
                        }
                    });

                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== DEBUG DETALHADO DE CORES =====
                    console.log('üîç DEBUG DETALHADO - CORES DOS MATERIAIS:');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    gltf.scene.traverse((child) => {
                        if (child.isMesh && child.material) {
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach((mat, idx) => {
                                console.log('--- MESH:', child.name, materials.length > 1 ? `[Material ${idx}]` : '', '---');
                                console.log('  Tipo material:', mat.type);

                                if (mat.color) {
                                    console.log('  Cor RGB:',
                                        'R:', mat.color.r.toFixed(3),
                                        'G:', mat.color.g.toFixed(3),
                                        'B:', mat.color.b.toFixed(3)
                                    );

                                    const hsl = {};
                                    mat.color.getHSL(hsl);
                                    console.log('  Cor HSL:',
                                        'H:', hsl.h.toFixed(3),
                                        'S:', hsl.s.toFixed(3),
                                        'L:', hsl.l.toFixed(3)
                                    );
                                    console.log('  ‚Üí Satura√ß√£o atual:', (hsl.s * 100).toFixed(1) + '%');
                                } else {
                                    console.log('  ‚ö†Ô∏è Sem cor (color)');
                                }

                                if (mat.map) {
                                    console.log('  ‚úì Tem textura (map):', mat.map.image ? 'carregada' : 'n√£o carregada');
                                } else {
                                    console.log('  ‚úó Sem textura (map)');
                                }

                                if (mat.emissive && mat.emissive.r + mat.emissive.g + mat.emissive.b > 0) {
                                    console.log('  ‚ö° Cor emissiva:',
                                        'R:', mat.emissive.r.toFixed(3),
                                        'G:', mat.emissive.g.toFixed(3),
                                        'B:', mat.emissive.b.toFixed(3)
                                    );
                                }
                            });
                        }
                    });

                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('üé® CONFIGURA√á√ÉO DO RENDERER:');
                    console.log('  ToneMapping:', renderer.toneMapping === THREE.LinearToneMapping ? 'LinearToneMapping' :
                                                   renderer.toneMapping === THREE.ReinhardToneMapping ? 'ReinhardToneMapping' :
                                                   renderer.toneMapping === THREE.ACESFilmicToneMapping ? 'ACESFilmicToneMapping' :
                                                   'Outro (' + renderer.toneMapping + ')');
                    console.log('  ToneMappingExposure:', renderer.toneMappingExposure);
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== EXTRAIR LUZES DO GLB =====
                    console.log('üí° Procurando luzes no GLB...');
                    let lightCount = 0;
                    gltf.scene.traverse((child) => {
                        if (child.isLight) {
                            lightCount++;
                            // TESTE: Desabilitar sombras
                            // child.castShadow = true;
                            console.log('  ‚úì Luz encontrada:', child.name, '- Tipo:', child.type);
                            console.log('    Intensidade:', child.intensity);
                            console.log('    Posi√ß√£o:', child.position.x.toFixed(2), child.position.y.toFixed(2), child.position.z.toFixed(2));
                        }
                    });

                    console.log('üí° Total de luzes encontradas:', lightCount);

                    // N√ÉO adicionar luzes extras - usar SOMENTE as do GLB
                    if (lightCount === 0) {
                        console.warn('‚ö†Ô∏è Nenhuma luz encontrada no GLB.');
                        console.log('  ‚Üí Usando apenas as luzes do GLB (nenhuma luz extra adicionada)');
                    }
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // ===== ANIMA√á√ïES =====
                    console.log('üé¨ Verificando anima√ß√µes...');
                    if (gltf.animations && gltf.animations.length > 0) {
                        console.log('üé¨ ANIMA√á√ïES ENCONTRADAS:', gltf.animations.length);
                        mixer = new THREE.AnimationMixer(model);

                        gltf.animations.forEach((clip, index) => {
                            console.log(`  ${index + 1}. Anima√ß√£o: "${clip.name}"`);
                            console.log('     Dura√ß√£o:', clip.duration.toFixed(2), 'segundos');
                            console.log('     Tracks:', clip.tracks.length);

                            const action = mixer.clipAction(clip);
                            action.loop = THREE.LoopRepeat;
                            action.timeScale = 1.0; // Velocidade natural
                            action.play();
                            animations.push(action);
                            console.log('     ‚úì Tocando em loop');
                        });

                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log('‚úÖ Todas as', gltf.animations.length, 'anima√ß√µes ativadas');
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    } else {
                        console.log('‚ö†Ô∏è Nenhuma anima√ß√£o encontrada no GLB');
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    }

                    // Criar bot√µes de c√¢mera
                    createCameraButtons();

                    // Esconder loading e mostrar controles
                    loadingDiv.style.display = 'none';
                    controlsDiv.style.display = 'block';

                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('‚úÖ TUDO PRONTO!');
                    console.log('   - Modelo carregado e adicionado √† cena');
                    console.log('   - C√¢mera ativa:', currentCamera.name);
                    console.log('   - Renderiza√ß√£o iniciada');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    // Iniciar anima√ß√£o
                    animate();
                },
                (xhr) => {
                    if (xhr.total > 0) {
                        const percent = Math.round((xhr.loaded / xhr.total) * 100);
                        loadingProgress.style.width = percent + '%';
                        loadingPercent.textContent = percent + '%';
                    }
                },
                (error) => {
                    console.error('‚ùå ERRO AO CARREGAR MODELO:');
                    console.error('   Erro:', error);
                    console.error('   Caminho:', CONFIG.modelPath);
                    console.error('   Verifique se o arquivo existe e o caminho est√° correto');
                    loadingPercent.textContent = 'Erro: ' + error.message;
                    loadingPercent.style.color = '#ff4444';
                }
            );
        }

        // ===== CRIAR BOT√ïES DE C√ÇMERA =====
        function createCameraButtons() {
            cameras.forEach((camera, index) => {
                const button = document.createElement('button');
                button.className = 'camera-btn';
                button.textContent = camera.name || `C√¢mera ${index + 1}`;
                button.onclick = () => switchCamera(index);

                if (index === 0) {
                    button.classList.add('active');
                }

                cameraButtonsDiv.appendChild(button);
            });
        }

        // ===== TROCAR C√ÇMERA =====
        function switchCamera(index) {
            currentCamera = cameras[index];

            // Atualizar aspect ratio
            if (currentCamera.isPerspectiveCamera) {
                currentCamera.aspect = window.innerWidth / window.innerHeight;
                currentCamera.updateProjectionMatrix();
            }

            // Atualizar c√¢mera no composer
            if (composer && composer.passes && composer.passes[0]) {
                composer.passes[0].camera = currentCamera;
            }

            // Atualizar bot√µes
            const buttons = document.querySelectorAll('.camera-btn');
            buttons.forEach((btn, i) => {
                if (i === index) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            console.log('üì∑ C√¢mera trocada para:', currentCamera.name);
        }

        // ===== ANIMA√á√ÉO =====
        let frameCount = 0;
        let lastLogTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Atualizar anima√ß√µes
            if (mixer) {
                mixer.update(delta);
            }

            // Renderizar com p√≥s-processamento
            if (currentCamera && composer) {
                composer.render();
                frameCount++;

                // Log a cada 60 frames (aproximadamente 1 segundo)
                if (frameCount === 60) {
                    const now = performance.now();
                    const fps = 60000 / (now - lastLogTime);
                    console.log('üé¨ Renderizando com p√≥s-processamento... FPS:', fps.toFixed(1), '| C√¢mera:', currentCamera.name);
                    frameCount = 0;
                    lastLogTime = now;
                }
            } else if (!composer) {
                console.error('‚ùå Composer n√£o inicializado!');
            } else {
                console.error('‚ùå Nenhuma c√¢mera ativa para renderizar!');
            }
        }

        // ===== RESIZE =====
        function onWindowResize() {
            if (currentCamera && currentCamera.isPerspectiveCamera) {
                currentCamera.aspect = window.innerWidth / window.innerHeight;
                currentCamera.updateProjectionMatrix();
            }
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // ===== INICIAR =====
        init();
    </script>
</body>
</html>
